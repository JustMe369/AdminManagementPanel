#!/bin/sh /etc/rc.common

# AdminManagement System Init Script for OpenWrt
# Place this file at /etc/init.d/adminmanagement on your OpenWrt router

START=99
STOP=10

USE_PROCD=1
PROG="/usr/bin/python3"
PID_FILE="/var/run/adminmanagement.pid"
WORK_DIR="/root/AdminManagementPanel"
MAIN_SCRIPT="$WORK_DIR/main_api_backend.py"
LOG_FILE="/var/log/adminmanagement.log"

validate_requirements() {
    # Check if Python3 is installed
    if ! command -v python3 >/dev/null 2>&1; then
        echo "Error: Python3 is not installed"
        return 1
    fi
    
    # Check if main script exists
    if [ ! -f "$MAIN_SCRIPT" ]; then
        echo "Error: Main script not found at $MAIN_SCRIPT"
        return 1
    fi
    
    # Check if work directory exists
    if [ ! -d "$WORK_DIR" ]; then
        echo "Error: Work directory not found at $WORK_DIR"
        return 1
    fi
    
    return 0
}

start_service() {
    # Validate requirements first
    if ! validate_requirements; then
        echo "AdminManagement service cannot start - requirements not met"
        return 1
    fi
    
    echo "Starting AdminManagement service..."
    
    # Create log directory if it doesn't exist
    mkdir -p "$(dirname "$LOG_FILE")"
    
    # Change to working directory
    cd "$WORK_DIR" || {
        echo "Failed to change to work directory"
        return 1
    }
    
    # Export environment variables
    export FLASK_ENV=production
    export PYTHONPATH="$WORK_DIR:$PYTHONPATH"
    
    # Start the service using procd
    procd_open_instance "adminmanagement"
    procd_set_param command "$PROG" "$MAIN_SCRIPT"
    procd_set_param pidfile "$PID_FILE"
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
    procd_set_param user root
    procd_set_param env FLASK_ENV=production
    procd_set_param env PYTHONPATH="$WORK_DIR"
    procd_close_instance
    
    echo "AdminManagement service started"
}

stop_service() {
    echo "Stopping AdminManagement service..."
    
    # Kill the main process if PID file exists
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid"
            sleep 2
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid"
            fi
        fi
        rm -f "$PID_FILE"
    fi
    
    # Kill any remaining python processes running the script
    pkill -f "$MAIN_SCRIPT"
    
    echo "AdminManagement service stopped"
}

reload_service() {
    echo "Reloading AdminManagement service..."
    stop_service
    sleep 2
    start_service
}

service_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

status() {
    if service_running; then
        local pid=$(cat "$PID_FILE")
        echo "AdminManagement service is running (PID: $pid)"
        
        # Check if the service is responding
        if command -v curl >/dev/null 2>&1; then
            if curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5000/api/status | grep -q "200"; then
                echo "Service is responding on port 5000"
            else
                echo "Service is not responding on port 5000"
            fi
        fi
        
        return 0
    else
        echo "AdminManagement service is not running"
        return 1
    fi
}

# Manual start function (for direct execution)
manual_start() {
    if ! validate_requirements; then
        echo "Cannot start - requirements not met"
        exit 1
    fi
    
    echo "Starting AdminManagement manually..."
    cd "$WORK_DIR"
    export FLASK_ENV=production
    export PYTHONPATH="$WORK_DIR:$PYTHONPATH"
    
    # Start in background with nohup
    nohup python3 "$MAIN_SCRIPT" > "$LOG_FILE" 2>&1 & 
    local pid=$!
    echo $pid > "$PID_FILE"
    
    echo "AdminManagement started with PID: $pid"
    echo "Log file: $LOG_FILE"
    echo "Access at: http://$(uci get network.lan.ipaddr):5000"
}

# Manual stop function
manual_stop() {
    echo "Stopping AdminManagement manually..."
    
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid"
            echo "Stopped process $pid"
        fi
        rm -f "$PID_FILE"
    fi
    
    # Kill any remaining processes
    pkill -f "$MAIN_SCRIPT"
    echo "AdminManagement stopped"
}

# Handle command line arguments for manual execution
case "$1" in
    "manual_start")
        manual_start
        ;;
    "manual_stop") 
        manual_stop
        ;;
    "status")
        status
        ;;
    *)
        # This allows the script to work both as init script and manual script
        if [ "$1" = "start" ] || [ "$1" = "stop" ] || [ "$1" = "restart" ] || [ "$1" = "reload" ]; then
            # Let procd handle it normally
            :
        else
            echo "Usage: $0 {start|stop|restart|reload|status|manual_start|manual_stop}"
            echo ""
            echo "Standard init commands:"
            echo "  start     - Start the service via procd"  
            echo "  stop      - Stop the service"
            echo "  restart   - Restart the service"
            echo "  reload    - Reload the service"
            echo ""
            echo "Manual commands:"
            echo "  manual_start - Start without procd (background process)"
            echo "  manual_stop  - Stop background process"
            echo "  status       - Show service status"
            echo ""
            echo "Examples:"
            echo "  /etc/init.d/adminmanagement start"
            echo "  /etc/init.d/adminmanagement manual_start"
            echo "  /etc/init.d/adminmanagement status"
            exit 1
        fi
        ;;
esac